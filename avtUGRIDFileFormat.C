/*****************************************************************************
*
* Copyright (c) 2000 - 2015, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtUGRIDFileFormat.C                           //
// ************************************************************************* //

#include <avtUGRIDFileFormat.h>

#include <netcdf.h>

#include <DebugStream.h>

#include <string>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkPoints.h>
#include <vtkCellType.h>
#include <vtkCellArray.h>
#include <vtkSmartPointer.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>


using     std::string;

// for some reason, there are two ways to read string attributes
// and it's difficult to predict which is correct.
string get_att_as_string(int ncid,int varid,const char *att_name) {
  int retval;
  char *att_data;
  string result("");

  if ( !(retval=nc_get_att_string(ncid, varid, att_name,&att_data)) ) {
    result=att_data; // is that legal?
    return result;
  }

  debug1 << "nc_get_att_string failed, will trying get_att_text" << endl;

  // is it possible that we have to test for text or string??
  size_t att_len;
  if ( nc_inq_attlen(ncid,varid,att_name,&att_len) ) {
    debug1 << "attlen also failed" << endl;
    return result;
  }

  char *buff=new char[att_len+1];
  if ( nc_get_att_text(ncid,varid,att_name,buff ) ) {
    delete[] buff;
    return result;
  }

  buff[att_len]='\0';
  result=buff;
  delete[] buff;
  return result;
}


VarInfo::VarInfo(std::string n) 
  : name(n) 
{
  init();
}

VarInfo::VarInfo(void)
{
  init();
}

void
VarInfo::init(void) 
{
  time_dimi=cell_dimi=layer_dimi=node_dimi=-1;
  var_id=-1;
  ncid=-1;
}

VarInfo::VarInfo(const VarInfo &a)
{
  // this really shouldn't be necessary, but it's acting up...
  name=a.name;
  mesh_name=a.mesh_name;
  time_dimi=a.time_dimi;
  cell_dimi=a.cell_dimi;
  layer_dimi=a.layer_dimi;
  node_dimi=a.node_dimi;
  time_dim=a.time_dim;
  cell_dim=a.cell_dim;
  layer_dim=a.layer_dim;
  node_dim=a.node_dim;
  var_id=a.var_id;
  // I think this actually happens pretty often...
  // debug1 << "Copied a varinfo with var_id " << var_id << endl;
  ncid=a.ncid;
}


// ****************************************************************************
//  Method: avtUGRIDFileFormat constructor
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Sat Mar 5 18:27:45 PST 2016
//
// ****************************************************************************

avtUGRIDFileFormat::avtUGRIDFileFormat(const char *filename)
  : avtMTSDFileFormat(&filename, 1)
{
  // INITIALIZE DATA MEMBERS
  int retval;
  
  if ( nc_open(filename, NC_NOWRITE, &ncid) ) {
    debug1 << "Failed to open " << filename << endl;
    return;
  } 
  debug1 << "UGRID: opened " << filename << endl;

  if ( nc_inq_dimid(ncid,"time", &time_dim) ) {
    debug1 << "Failed to read time dimensions" << endl;
  }

  if ( nc_inq_varid(ncid, "time", &time_var) ) {
    debug1 << "Couldn't read time variable id" << endl;
    return;
  }

  cell_kmin=cell_kmax=NULL;
  active_timestate=-1;

  // FIX: should be figured out based on cf_role
  if ((retval = nc_inq_varid(ncid, "FlowMesh", &mesh_var))) {
    debug1 << "Couldn't read mesh variable id FlowMesh" << endl;
    return;
  }

  debug1 << "UGRID:: Found a mesh variable..." << endl;

  // Basic dimensions:
  // for the moment, depends on the presence of a volume variable, which
  // is assumed to have time,cell,layer dimensions
  int vol_var;
  if( nc_inq_varid(ncid,"volume",&vol_var) ) {
    debug1 << "Failed to read volume variable to figure out dimensions" << endl;
    return;
  }
  int vol_dimids[3];
  if ( nc_inq_vardimid(ncid,vol_var,vol_dimids) ) {
    debug1 << "Failed to read volume dimensions ids" << endl;
    return;
  }
  cell_dim=vol_dimids[1];
  layer_dim=vol_dimids[2];
  if (  nc_inq_dimlen(ncid,cell_dim,&n_cells)  ||
        nc_inq_dimlen(ncid,layer_dim,&n_layers) ) {
    debug1 << "Failed to read dimensions of volume variable" << endl;
    return;
  }

  // this is working, so the var id for volume is good..
  debug1 << "UGRID: got a volume variable... " << endl;
  debug1 << "Read n_layers=" << n_layers << " and n_cells="<< n_cells << endl;
 
  // Load node metadata - not sure why nc_get_att_string doesn't work..
  default_ugrid_mesh=var_mesh("volume");

  string ugrid_mesh=default_ugrid_mesh;
  debug1 << "Deduced mesh name: " << ugrid_mesh << endl;

  debug1 << "UGRID:GetNodes: ugrid mesh name " << ugrid_mesh << endl;

  if ( nc_inq_varid(ncid,ugrid_mesh.c_str(),&mesh_var) ) {
    debug1 << "UGRID:GetMeshNodes: Failed to find mesh variable" << endl;
    return;
  }

  debug1 << "UGRID: poking around for node coordinates " << endl;
  debug1 << "UGRID: mesh_var for that mesh name is " << mesh_var << endl;

  string node_coords=get_att_as_string(ncid,mesh_var,"node_coordinates");
  if( node_coords=="" ) return;

  // netcdf says we have to do this, but it's causing problems...
  //nc_free_string(strlen(att_data),&att_data);

  debug1 << "Node coordinate values " << node_coords << endl;

  string node_x=node_coords.substr(0,node_coords.find_first_of(" "));
  debug1 << "node x variable '" << node_x << "'" << endl;
  string node_y=node_coords.substr(node_coords.find_last_of(" ")+1,
                                   node_coords.length());
  debug1 << "node y variable '" << node_y << "'" << endl;

  if( nc_inq_varid(ncid,node_x.c_str(),&node_x_var) ) {
    debug1 << "Failed to find node_x variable" << endl;
    return;
  }
  if( nc_inq_varid(ncid,node_y.c_str(),&node_y_var) ) {
    debug1 << "Failed to find node_y variable" << endl;
    return;
  }

  // _assume_ that they have exactly one dimension.
  nc_inq_vardimid(ncid,node_x_var,&node_dim);

  nc_inq_dimlen(ncid,node_dim,&n_nodes);
  
  debug1 << "Found " << n_nodes << " nodes" << endl;

}

avtUGRIDFileFormat::~avtUGRIDFileFormat() {
  delete[] cell_kmin;
  delete[] cell_kmax;
}

string avtUGRIDFileFormat::var_mesh(std::string varname) {
  int varid;
  nc_inq_varid(ncid,varname.c_str(),&varid);
  return var_mesh(varid);
}

string avtUGRIDFileFormat::var_mesh(int varid) {
  // any reason not to use this same convenience util?
  return get_att_as_string(ncid,varid,"mesh");
}

// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Sat Mar 5 18:27:45 PST 2016
//
// ****************************************************************************

int
avtUGRIDFileFormat::GetNTimesteps(void)
{
  size_t length;
  char recname[NC_MAX_NAME+1];
  nc_inq_dim(ncid, time_dim, recname, &length);

  return length;
}

void avtUGRIDFileFormat::GetCycles(std::vector<int> &cycles)
{
  int nsteps=GetNTimesteps();

  if ( nsteps == 0 ) {
    // put in a fake 0 timestep
    cycles.push_back(0);
  } else {
    for(int i=0;i<nsteps;i++) {
      cycles.push_back(i);
    }
  }
}


void avtUGRIDFileFormat::GetTimes(std::vector<double> &times)
{
  // use days to make it a bit friendlier
  size_t startp[1]; // safely assume that time is one-dimensional
  size_t countp[1];

  countp[0]=GetNTimesteps();
  startp[0]=0;

  double *result=new double[countp[0]];

  if( nc_get_vara_double(ncid,time_var,startp,countp,result) ) {
    debug1 << "Failed to read double array for time " << endl;
    delete[] result;
  }

  double to_days=1;

  string units=get_att_as_string(ncid,time_var,"units");

  if ( units.find("second")== 0) {
    to_days=1./86400;
  } else if ( units.find("minute")==0 ) {
    to_days=1./(24*60);
  } else if ( units.find("hour")==0) {
    to_days=1./24;
  } else if ( units.find("day")==0 ) {
    to_days=1.;
  } else {
    debug1 << "UGRID::GetTimes: couldn't understand units " << units << endl;
  }

  if ( countp[0] == 0 ) {
    // put in a fake 0 timestep
    times.push_back(0.0);
  } else {
    for(int i=0;i<countp[0];i++) {
      times.push_back(result[i]*to_days);
    }
  }
  delete[] result;
}



// ****************************************************************************
//  Method: avtUGRIDFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Sat Mar 5 18:27:45 PST 2016
//
// ****************************************************************************

void
avtUGRIDFileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avtUGRIDFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Sat Mar 5 18:27:45 PST 2016
//
// ****************************************************************************

void
avtUGRIDFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
  string ugrid_mesh=default_ugrid_mesh;

  string meshname = ugrid_mesh+".2d";
  // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
  // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
  avtMeshType mt = AVT_UNSTRUCTURED_MESH;

  int nblocks = 1;  // <-- this must be 1 for MTSD
  int block_origin = 0;
  int spatial_dimension = 2;
  int topological_dimension = 2;
  double *extents = NULL;

  AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
                    spatial_dimension, topological_dimension);

  AddMeshToMetaData(md, 
                    ugrid_mesh+".3d", // mesh name
                    AVT_UNSTRUCTURED_MESH, // mesh type
                    NULL, // extents
                    1,    // nblocks
                    0,    // block origin
                    3,   // spatial dimension
                    3   // topological dimension
                    );

  // variable centering:
  // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT

  AddMeshToMetaData(md,ugrid_mesh+".nodes",AVT_POINT_MESH,NULL,1,0,2,0);

  // Loop through variables in file, trying to match them to grids
  // and register with metadata
  int nvars;
  if ( nc_inq_nvars(ncid,&nvars) ) {
    debug1 << "Failed. How could nc_inq_nvars fail??" << endl;
    return;
  }

  debug1 << "UGRID: Scanning variable definitions" << endl;

  char var_scan[NC_MAX_NAME];
  
  for(int var_num=0;var_num<nvars;var_num++) {
    if ( nc_inq_varname(ncid,var_num,var_scan) ) {
      debug1 << "Failed to read name of variable at index " << var_num << endl;
    } else {
      debug1 << "Variable: "<<var_scan << " [" << var_num << "]" <<endl;

      // read dimensions - if it has either cell/node and a layer dimension, assign to
      // 3D mesh.
      // if just cell/node, put it on the 2d mesh.
      int dims[6]; // who would have more than 6 dimensions??
      int ndim;

      if( nc_inq_varndims(ncid,var_num,&ndim) || 
          nc_inq_vardimid(ncid,var_num,dims) ) {
        debug1 << "Failed.  How did that happen?" << endl;
        continue;
      }
      int extra_dims=0;

      VarInfo var_inf(var_scan);
      var_inf.var_id=var_num;
      var_inf.time_dim=time_dim;
      // var_inf.time_dimi=-1;  // apparently....
      // var_inf.cell_dimi=-1;  // this
      // var_inf.layer_dimi=-1; // does need to be done...
      // var_inf.node_dimi=-1;  // constructor not really doing it's job?

      // these will shortly be moved to a shared mesh object
      var_inf.layer_dim=layer_dim;
      var_inf.cell_dim=cell_dim;
      var_inf.node_dim=node_dim;
      var_inf.ncid=ncid;
      for( int d=0;d<ndim;d++) {
        if ( dims[d] == cell_dim )
          var_inf.cell_dimi=d;
        else if (dims[d] == layer_dim )
          var_inf.layer_dimi=d;
        else if (dims[d] == time_dim ) 
          var_inf.time_dimi=d;
        else if (dims[d] == node_dim )
          var_inf.node_dimi=d;
        else
          extra_dims++;
      }
      var_inf.mesh_name=var_mesh(var_scan);
      if ( var_inf.mesh_name != ugrid_mesh ) {
        if ( var_inf.mesh_name != "" )  {
          debug1 << "Found another ugrid mesh.  Not ready for that." << endl;
        }
        continue;
      }

      if ( extra_dims>0 ) {
        debug1 << "Variable " << var_scan << " has extra dimensions.  Not ready..." << endl;
        continue;
      }

      debug1 << "  layer_dimi: " << var_inf.layer_dimi << endl;
      
      avtScalarMetaData *smd=new avtScalarMetaData;
      smd->name=var_scan;
      string units=get_att_as_string(ncid,var_inf.var_id,"units");
      if (units != "" ) {
        smd->hasUnits=true;
        smd->units=units;
      }
      
      if ( var_inf.layer_dimi>=0 ) {
        smd->meshName=var_inf.mesh_name+".3d";
        if ( var_inf.cell_dimi>=0 ) {
          smd->centering=AVT_ZONECENT;
          md->Add(smd);
          // AddScalarVarToMetaData(md, var_scan, var_inf.mesh_name+".3d", AVT_ZONECENT);
        } else if( var_inf.node_dimi>=0 ) {
          // probably don't have any of these
          smd->centering=AVT_NODECENT;
          md->Add(smd);
          // AddScalarVarToMetaData(md, var_scan, var_inf.mesh_name+".3d", AVT_NODECENT);
        } else {
          delete smd;
          smd=NULL;
          debug1 << "Will ignore " << var_scan << " b/c it doesn't have a horizontal dimension"
                 << endl;
        }
      } else { 
        // no layer
        smd->meshName=var_inf.mesh_name+".2d";
        if ( var_inf.cell_dimi>=0 ) {
          smd->centering=AVT_ZONECENT;
          md->Add(smd);
          // AddScalarVarToMetaData(md, var_scan, var_inf.mesh_name+".2d", AVT_ZONECENT);
        } else if ( var_inf.node_dimi>=0 ) {
          smd->centering=AVT_NODECENT;
          md->Add(smd);
          //AddScalarVarToMetaData(md, var_scan, var_inf.mesh_name+".2d", AVT_NODECENT);
        } else {
          delete smd;
          smd=NULL;
          debug1 << "Will ignore " << var_scan << " b/c it doesn't have a horizontal dimension"
                 << endl;
        }
      }
      var_table[var_scan] = var_inf;
    }
  }
  
  //
  // CODE TO ADD A VECTOR VARIABLE
  //
  // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
  // string varname = ...
  // int vector_dim = 2;
  //
  // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
  // avtCentering cent = AVT_NODECENT;
  //
  //
  // Here's the call that tells the meta-data object that we have a var:
  //
  // AddVectorVarToMetaData(md, varname, mesh_for_this_var, cent,vector_dim);
  //
}


// ****************************************************************************
//  Method: avtUGRIDFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Sat Mar 5 18:27:45 PST 2016
//
// ****************************************************************************


vtkPoints *avtUGRIDFileFormat::GetNodes(const string ugrid_mesh) 
{
  float *xcoords=new float[n_nodes];
  float *ycoords=new float[n_nodes];

  if ( nc_get_var_float(ncid, node_x_var, xcoords) ) {
    debug1 << "Failed to read x coordinate" << endl;
    return NULL;
  }
  if ( nc_get_var_float(ncid, node_y_var, ycoords) ) {
    debug1 << "Failed to read y coordinate" << endl;
    return NULL;
  }
  
  debug1 << "Read coordinates" << endl;

  vtkPoints *points = vtkPoints::New();
  points->SetDataTypeToFloat();
  points->SetNumberOfPoints(n_nodes);
  
  float pnt[3];
  for(int n=0;n<n_nodes;n++){
    pnt[0]=xcoords[n];
    pnt[1]=ycoords[n];
    pnt[2]=0.0; // unused 
    points->SetPoint(n,pnt);
  }
  
  delete[] xcoords;
  delete[] ycoords;

  return points;
}

vtkUnstructuredGrid *avtUGRIDFileFormat::GetMeshNodes(const string ugrid_mesh) 
{
  vtkPoints *points=GetNodes(ugrid_mesh);

  int n_nodes=points->GetNumberOfPoints();

  vtkIdType onevertex;

  vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New();
  ugrid->SetPoints(points);
  points->Delete();

  for(int n=0;n<n_nodes;n++) {
    onevertex = n;
    ugrid->InsertNextCell(VTK_VERTEX,1,&onevertex);
  }

  return ugrid;
}

vtkDataSet *
avtUGRIDFileFormat::GetMesh(int timestate, const char *meshname)
{
  string requested(meshname);
  string ugrid_mesh;
  int ndim;
  int retval;

  if ( requested.find(".nodes") != string::npos) {
    ugrid_mesh = requested.substr(0,requested.length()-6);
    debug1 << "UGRID:GetMesh: requested '"<< requested << "' - will hand to GetMeshNodes" << endl;
    return GetMeshNodes(ugrid_mesh);
  } 

  if(  requested.find(".2d",requested.length()-3) != string::npos ) {
    ugrid_mesh = requested.substr(0,requested.length()-3);
    debug1 << "Found 2d mesh name" << endl;
    ndim=2;
  } else if ( requested.find(".3d",requested.length()-3) != string::npos ) {
    ugrid_mesh = requested.substr(0,requested.length()-3);
    debug1 << "Found 3d mesh name" << endl;
    ndim=3;
  } else {
    debug1 << "In mesh name '"<<meshname<<"' couldn't decipher ugrid mesh" << endl;
    return NULL;
  }

  // the others are built on top of the node mesh
  vtkPoints *points = GetNodes(ugrid_mesh);
  
  vtkUnstructuredGrid *mesh=vtkUnstructuredGrid::New();
  mesh->SetPoints(points);
  points->Delete() ; // pretty sure this is correct...
  mesh->Allocate();

  // read the node_face info, build up triangles/quads.
  debug1 << "GetMesh: ugrid mesh name " << ugrid_mesh << endl;

  int mesh_var;
  if ( nc_inq_varid(ncid,ugrid_mesh.c_str(),&mesh_var) ) {
    debug1 << "UGRID:GetMesh: Failed to find mesh variable" << ugrid_mesh << endl;
    return NULL;
  }

  nc_type xtype;
  
  string face_node=get_att_as_string(ncid,mesh_var,"face_node_connectivity");

  // netcdf says we have to do this, but it's causing problems...
  //nc_free_string(strlen(att_data),&att_data);

  debug1 << "Face-Node connectivity " << face_node << endl;

  int face_node_var;

  if( nc_inq_varid(ncid,face_node.c_str(),&face_node_var) ) {
    debug1 << "Failed to find face_node_connectivity variable" << endl;
    return NULL;
  }

  int f_n_dims[2]; // _assume_ face_node_connectivity has two dimensions, [Nfaces,MaxNodePerFace]
  nc_inq_vardimid(ncid,face_node_var,f_n_dims);
  
  int face_node_fill=-1; // default to -1...

  if ( nc_get_att_int(ncid,face_node_var,"_FillValue", &face_node_fill) ) {
    debug1 << "Failed to find fill value for face_node_connectivity - will assume " 
           << face_node_fill << endl;
  }

  size_t max_node_per_face;
  nc_inq_dimlen(ncid,f_n_dims[1],&max_node_per_face);
  
  int *faces=new int[n_cells*max_node_per_face];

  if ( nc_get_var_int(ncid, face_node_var, faces) ) {
    debug1 << "Failed to read face_node_var" << endl;
    return NULL;
  }

  debug1 << "UGRID: max node per face: " << max_node_per_face << endl;

  // Load as 2D, then optionally extrude to 3D
  vtkIdType *vertices=new vtkIdType[max_node_per_face];
    
  for(int f=0;f<n_cells;f++) {
    int n;
    for(n=0;n<max_node_per_face;n++) {
      if (faces[f*max_node_per_face+n] == face_node_fill ) 
        break;
      // last dimension varies fastest
      vertices[n] = faces[f*max_node_per_face + n]; // have to see if this is the right order
    }
    // This is failing - it's saying ERROR: bad cell type??
    switch ( n ) {
    case 3:
      if ( f==0 ) {
        debug1 << "UGRID:GetMesh: inserting triangle cell, vertices=" 
               << vertices[0] << " " << vertices[1] << " " << vertices[2] << endl;
      }
      mesh->InsertNextCell(VTK_TRIANGLE,n,vertices);
      break;
    case 4: 
      mesh->InsertNextCell(VTK_QUAD,n,vertices);
      debug1 << "UGRID: Trying to insert VTK_QUAD" << endl;
      break;
    default:
      debug1 << "UGRID: Trying to insert VTK_POLYGON" << endl;
      mesh->InsertNextCell(VTK_POLYGON,n,vertices);
    }
  }
  delete[] vertices;
  delete[] faces;
  
  if ( ndim==3 ) {
    debug1 << "UGRID: Extruding grid" << endl;
    vtkDataSet *result=ExtrudeTo3D(ugrid_mesh,timestate,mesh);
    debug1 << "UGRID: got extruded grid" << endl;
    return result;
  } else {
    return mesh;
  }
}

/**
   Dirty work of creating a prism with more than 6 nodes on top and bottom
   Ordering of the points making up faces is in the sense of a positive 
   outward facing normal.  i.e. a right-hand rule curling in the order of
   nodes gives the outward normal.  Equivalently, when viewed from outside
   the volume, nodes are ordered CCW.

   Assume that internally the nodes of a cell are stored in CCW order.  So
   the top face of the prism is already in the proper order.
 **/ 
void
insertNPrism(vtkUnstructuredGrid *full_mesh,
             int npoints2d,
             vtkIdType *point_ids) {
  // following http://www.vtk.org/Wiki/VTK/Examples/Cxx/GeometricObjects/Polyhedron
  vtkSmartPointer<vtkCellArray> faces =
    vtkSmartPointer<vtkCellArray>::New();

  vtkIdType *face=new vtkIdType[npoints2d];

  // create the top:
  for(int i=0;i<npoints2d;i++) {
    face[i]=point_ids[i]; // already proper order, I think.
  }
  faces->InsertNextCell(npoints2d, face);
  for(int i=0;i<npoints2d;i++) {
    // and the bottom - reverse the order
    face[i]=point_ids[2*npoints2d - 1 - i]; // old: npoints2d+i
  }
  faces->InsertNextCell(npoints2d, face);

  // and each side facet:
  for(int facet=0;facet<npoints2d;facet++) {
    face[3]=point_ids[facet];
    face[2]=point_ids[(facet+1)%npoints2d];
    face[1]=point_ids[npoints2d+(facet+1)%npoints2d];
    face[0]=point_ids[npoints2d+facet];
    faces->InsertNextCell(4,face);
  }

  full_mesh->InsertNextCell(VTK_POLYHEDRON, 2*npoints2d, point_ids,
                            2+npoints2d, faces->GetPointer());
  delete[] face;
}


vtkDataSet *
avtUGRIDFileFormat::ExtrudeTo3D(string ugrid_mesh,int timestate,
                                vtkUnstructuredGrid *surface)
{
  ////// Now basically extrude the surface mesh to prisms
  // bounded by the cell_divisions elevations 

  activateTimestate(timestate);

  // the new points 
  // copy the z=0 points from the flat surface, and then repeat
  // for each z-value 
  int n_surf_points = surface->GetNumberOfPoints();
  int offset;
  
  // for z-grid:
  //   have a vertical dimension - in the current file, nFlowMesh_layers
  //   hopefully that has a bounds attribute, which points to a variable
  //   with dimensions nFlowMesh_layers,2, giving top and bottom elevation
  //   of the z-layers.
  
  // max number of points in each column:
  size_t num_layers;
  int layer_var;
  
  if ( nc_inq_varid(ncid,"nFlowMesh_layers",&layer_var) ){
    debug1 << "Failed to find layer variable" << endl;
    return NULL;
  }

  int layer_dims[3]; // just to be safe..
  if( nc_inq_vardimid(ncid,layer_var,layer_dims) ) {
    debug1 << "failed to find layer dimension" << endl;
    return NULL;
  }

  // and the bounds variable?
  string bounds_name=get_att_as_string(ncid,layer_var,"bounds");
  if ( bounds_name == "" ) {
    debug1 << "Failed to find bounds attribute" << endl;
    return NULL;
  }
  int bounds_var;
  if( nc_inq_varid(ncid,bounds_name.c_str(),&bounds_var) ) {
    debug1 << "Failed to find bounds variable" << endl;
    return NULL;
  }

  debug1 << "Found bounds variable" << endl;

  // for starters, assume that we have a bounds variable

  int n_per_column=1+n_layers;

  // for z-layers, one set of z coordinates for the whole grid.
  // (ignoring partial layers for a moment)
  float *layer_bounds=new float[2*n_per_column];
  if ( nc_get_var_float(ncid,bounds_var,layer_bounds) ) {
    debug1 << "Failed to read layer bounds" << endl;
    return NULL;
  }

  vtkPoints *all_points = vtkPoints::New();
  all_points->SetNumberOfPoints( n_per_column*n_surf_points );
  float *ap_data = (float*)all_points->GetVoidPointer(0);
  double *surf_point;
  float *a_point;
  
  for(int surf_point_id=0;surf_point_id<n_surf_points;surf_point_id++) {
    surf_point = surface->GetPoint(surf_point_id);
    for(int k=0;k<n_per_column;k++){
      // pointer to the point being defined
      a_point = ap_data + 3*(surf_point_id+k*n_surf_points);
      
      a_point[0] = surf_point[0];
      a_point[1] = surf_point[1];
      // assumes that bounds are continuous - bottom of one cell same
      // as top of the next
      if(k==0) {
        a_point[2] = layer_bounds[0];
      } else {
        a_point[2] = layer_bounds[2*(k-1)+1];
      }
    }
  }
  
  vtkUnstructuredGrid *full_mesh = vtkUnstructuredGrid::New();
   
  // Copy the cell structure, extruding through depth
  vtkIdType surf_cell_npoints;
  vtkIdType *surf_cell_point_ids;
  
  // 2*MAX_SIDES: top and bottom points, up to a hexagonal prism, or larger??
  vtkIdType new_cell_point_ids[2*MAX_SIDES];
  
  // full_cell2valid provides a mapping of expected cell index to
  //  actual cell index;
  
  // settings['stairstep']=0 ->  The bottom of the bottom valid cell is defined
  //   by the voronoi center depth
  //                      =1 ->  Round to next z-level (deeper)
  // It's going to be a real pain to do partial depths, because it
  //  upsets the mapping of points to different depths (bottom points
  //   can't be reused, and the numbering gets all funky)
  
  // Fetch the depth values in order to evaluate the bottom cells
  // this is a little different for the ugrid stuff.
  //  probably have node-centered depth
  //  what's the CF convention say about this?
  //  could create the full mesh?
  //  probably it is supposed to be a [time,cell,layer] variable
  //  in the netcdf.
  //  there's the further consideration that really we want bounds, too,
  //  so it would be [time,cell,layer,d2]
  // regardless, this needs to be time-dependent.
  
  // the most immediate question is how to figure out how many 
  // cells are in each water column.
  
  // vtkFloatArray *cell_depths =(vtkFloatArray *)GetVarBathymetry();
  // float *bath_data = cell_depths->GetPointer(0);
  
  full_mesh->Allocate();
   
  int expected_cell_id=0;
  int real_cell_id=0;
     
  for(int surf_cell_id=0 ;
      surf_cell_id<n_cells ;
      surf_cell_id++ ) {
    // need to acount for different number of sides
    // int npoints=0;
    
    surface->GetCellPoints(surf_cell_id,
                           surf_cell_npoints,surf_cell_point_ids);

    if( surf_cell_npoints > MAX_SIDES ) {
      debug1 << "Cell has too many points - truncating! " << surf_cell_npoints << " to " << MAX_SIDES << endl;
      surf_cell_npoints=MAX_SIDES;
    }
   
    int k; // index into vertical cells
    
    for(k=cell_kmin[surf_cell_id];
        k<cell_kmax[surf_cell_id];
        k++) {
      
      /// The Visit manual shows this as 0-1-2 being one triangular
      // face with outward-facing normal, and 3-4-5 being the other
      // end with inward-facing normal (where the normal is defined
      // as outward on CCW ordered vertices)
      // if this really angers Visit, may have to test ordering here
      // and reverse top/bottom if vertices are in wrong order.

      // but the general polyhedron wants entirely outward facing
      // normals.
      // and the illustration of thw VTK_HEXAHEDRON 
      // shows 0,1,2,3 having an inward facing normal.
      
      // at some point we might add new bottom points to allow
      // for partial cell depths, but for now just do stair-stepping

      // tricky loop modification to order the nodes in the right way
      // for the different cell types.
      if( surf_cell_npoints==3 || surf_cell_npoints>6 )
        offset=0;
      else
        offset=surf_cell_npoints;
      
      // the upper level:
      for (int vertex=0;vertex<surf_cell_npoints;vertex++) {
        new_cell_point_ids[vertex+offset] = k*n_surf_points + surf_cell_point_ids[vertex];
      }

      offset=surf_cell_npoints-offset;
      
      // the lower level:
      for (int vertex=0;vertex<surf_cell_npoints;vertex++) {
        new_cell_point_ids[vertex+offset] = (k+1)*n_surf_points + 
          surf_cell_point_ids[vertex];
      }
        
      // Insert the cell into the mesh.
      if ( surf_cell_npoints==3 ) {
        full_mesh->InsertNextCell(VTK_WEDGE, 6, new_cell_point_ids);
      } else if (surf_cell_npoints==4 ) {
        full_mesh->InsertNextCell(VTK_HEXAHEDRON, 8, new_cell_point_ids);
      } else if (surf_cell_npoints==5 ) {
        full_mesh->InsertNextCell(VTK_PENTAGONAL_PRISM, 10, new_cell_point_ids);
      } else if (surf_cell_npoints==6 ) {
        full_mesh->InsertNextCell(VTK_HEXAGONAL_PRISM, 12, new_cell_point_ids);
      } else {
        debug1 << "Surface cell has " << surf_cell_npoints << " points, which is simply too many" << endl;
        insertNPrism(full_mesh,surf_cell_npoints,new_cell_point_ids);
        // full_mesh->InsertNextCell(VTK_HEXAGONAL_PRISM, 12, new_cell_point_ids);
      }
      
      // update the mapping of cell ids:
      // the order of the data file is still a bit unclear, so hopefully
      // this is the same as in the data file...
      int expected_id = surf_cell_id + k*n_cells;
   
      full_cell2valid[ expected_id ] = real_cell_id;
        
      real_cell_id++;
    }
  }
  debug1 << "Done constructing 3D cells" << endl;
  
  // hopefully it's okay to set the points here, *after* defining the cells
  full_mesh->SetPoints(all_points);
  all_points->Delete();
  surface->Delete();
   
  // n_3d_cells = full_mesh->GetNumberOfCells();

  full_mesh->Register(NULL);

  debug1 << "Return 3D mesh" << endl;

  return full_mesh;
}


void avtUGRIDFileFormat::activateTimestate(int timestate) {
  if (timestate == active_timestate )
    return;

  ncells_3d=0;

  if(!cell_kmin) {
    cell_kmin = new int[n_cells];
  }
  if(!cell_kmax) {
    cell_kmax = new int[n_cells];
  }

  // use the volumes variable to figure out 
  float *volumes=read_cell_z_full("volume",timestate);
  if ( !volumes ) return;

  for(int cell2d=0;cell2d<n_cells;cell2d++)  {
    // cell_kmin from first non-zero volume
    int k;
    for(k=0;
        (k<n_layers) && (volumes[cell2d*n_layers+k] <= 0);
        k++) ;

    cell_kmin[cell2d]=k;
    for(; (k<n_layers) && ( volumes[cell2d*n_layers+k]==volumes[cell2d*n_layers+k] );
        k++) ;
    cell_kmax[cell2d]=k;
    ncells_3d += (cell_kmax[cell2d] - cell_kmin[cell2d]);
  }

  active_timestate=timestate;
}


float * VarInfo::read_cell_at_time(int timestate)
{
  size_t n_cells;
  if ( nc_inq_dimlen(ncid,cell_dim,&n_cells) ) {
    debug1 << "Somehow late read of n_cells failed" << endl;
    return NULL;
  }

  debug1 << "read_cell_at_time: allocating " << n_cells << endl;

  float * result=new float[n_cells];
  size_t startp[2];
  size_t countp[2];

  // assume that the dimensions are time,cell,layer
  if( time_dimi >= 0 ){
    startp[time_dimi] = timestate;
    countp[time_dimi]=1;
  }
  startp[cell_dimi] = 0;
  countp[cell_dimi]=n_cells;

  for(int d=0;d<2;d++) {
    //debug1 << "  startp[
  }
  
  if( nc_get_vara_float(ncid,var_id,startp,countp,result) ) {
    debug1 << "Failed to read float array for " << name << endl;
    delete[] result;
    return NULL;
  }
  debug1 << "Finishing read_cell_at_time of " << name << endl;
  return result;
}

float *VarInfo::read_cell_z_at_time(int timestate) {
  size_t n_cells,n_layers;

  if ( nc_inq_dimlen(ncid,cell_dim,&n_cells) ||
       nc_inq_dimlen(ncid,layer_dim,&n_layers) ) {
    debug1 << "Somehow late read of n_cells or n_layers failed" << endl;
    return NULL;
  }

  debug1 << "read_cell_z_at_time: allocating " << n_cells << "x" << n_layers << endl;

  float * result=new float[n_cells*n_layers];
  size_t startp[3];
  size_t countp[3];

  // assume that the dimensions are time,cell,layer
  if( time_dimi>=0 ) {
    startp[time_dimi] = timestate;
    countp[time_dimi]=1;
  } 

  debug1 << "read_cell_z_at_time: time_dimi="<< time_dimi << endl;
  debug1 << "                     cell_dimi="<< cell_dimi << endl;
  debug1 << "                    layer_dimi="<< layer_dimi << endl;

  startp[cell_dimi] = 0;
  countp[cell_dimi]=n_cells;

  startp[layer_dimi]=0;
  countp[layer_dimi]=n_layers;

  for(int i=0;i<3;i++){
    debug1 << "dim " << i << ": start=" << startp[i] << "  count="<<countp[i] << endl;
  }

  char var_scan[NC_MAX_NAME];
  if ( nc_inq_varname(ncid,var_id,var_scan) ) {
    debug1 << "Failed to read varname for var_id=" << var_id << endl;
    return NULL;
  } else {
    debug1 << "Expected var name " << name << " and queried to get " << var_scan << endl;
  }

  // this is failing, but not clear why...
  // maybe double check to make sure that var_id is correct?
  // could also print startp and countp, and query number of dimensions?

  if( nc_get_vara_float(ncid,var_id,startp,countp,result) ) {
    debug1 << "Failed to read 3D float array for " << name << endl;
    delete[] result;
    return NULL;
  } else {
    debug1 << "Successfully read 3D float array for " << name << endl;
  }

  return result;
}

// Read a 3D netcdf variable by name and timestate.  
// Caller is responsible for freeing the result
float *
avtUGRIDFileFormat::read_cell_z_full(std::string varname,int timestate) 
{
  return var_table[varname].read_cell_z_at_time(timestate);
}

// ****************************************************************************
//  Method: avtUGRIDFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Sat Mar 5 18:27:45 PST 2016
//
// ****************************************************************************

vtkDataArray *
avtUGRIDFileFormat::GetVar(int timestate, const char *varname)
{
  VarInfo vi=var_table[varname];

  if ( vi.layer_dimi >= 0 ) {
    debug1 << "GetVar(" << timestate << "," << varname << ") => GetVar3D" << endl;
    return GetVar3D(timestate,vi);
  } else {
    debug1 << "GetVar(" << timestate << "," << varname << ") => GetVar2D" << endl;
    return GetVar2D(timestate,vi);
  }
}

vtkDataArray *
avtUGRIDFileFormat::GetVar3D(int timestate,VarInfo &vi)
{ 
  activateTimestate(timestate);

  vtkFloatArray *rv = vtkFloatArray::New();
  rv->SetNumberOfTuples(ncells_3d);
  rv->SetNumberOfComponents(1);

  float *full=read_cell_z_full(vi.name,timestate);
  
  int i3d=0;
  for(int surf_cell=0;surf_cell<n_cells;surf_cell++) {
    for(int k=cell_kmin[surf_cell];k<cell_kmax[surf_cell];k++) {
      rv->SetTuple1(i3d,full[surf_cell*n_layers+k]);
      i3d++;
    }
  }
  delete[] full;
  return rv;
}

vtkDataArray *
avtUGRIDFileFormat::GetVar2D(int timestate,VarInfo &vi)
{ 
  activateTimestate(timestate);

  vtkFloatArray *rv = vtkFloatArray::New();
  rv->SetNumberOfTuples(n_cells);
  rv->SetNumberOfComponents(1);

  debug1 << "GetVar2D(" << timestate << "," << vi.name << ") allocated " << n_cells << endl;
  float *full=vi.read_cell_at_time(timestate);
  
  for(int i=0;i<n_cells;i++) {
    rv->SetTuple1(i,full[i]);
  }

  debug1 << "Done with GetVar2D for " << vi.name << endl;
  return rv;
}


// ****************************************************************************
//  Method: avtUGRIDFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Sat Mar 5 18:27:45 PST 2016
//
// ****************************************************************************

vtkDataArray *
avtUGRIDFileFormat::GetVectorVar(int timestate, const char *varname)
{
  // YOU MUST IMPLEMENT THIS
  return NULL;
  
    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    // delete [] one_entry;
    // return rv;
    //
}


// things to fix in the netcdf: 
//  add mesh attribute to more variables - like _zcc
//  need to figure out proper way of dealing with volume, vertical coordinates, etc.
